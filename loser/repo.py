"""Repository sources."""
import functools
import os
import re
from abc import ABC, abstractmethod
from collections.abc import Mapping
from types import MappingProxyType

import aiohttp
import boto3


class Repo(Mapping, ABC):
    """Represents a mapping from package names to their artifact names and
    downloadable packages.

    A repo presents a mapping interface to an internal package mapping
    that can be generated by the implementation of the `_refresh()`
    method.

    """
    def __init__(self):
        self._tree = {}

    @abstractmethod
    def _refresh(self):
        """Implement this method to populate the internal ``self._tree`` dictionary.

        This dictionary represents the repo contents. On the first
        level, the keys are package names. Each value of this first
        level is itself a dictionary mapping a specific artifact to a
        Package-like object (an object with a download method).
        """
        raise NotImplementedError

    def __getitem__(self, key):
        self._refresh()
        tree = {normalize(k): v for k, v in self._tree.items()}
        return MappingProxyType(tree[normalize(key)])

    def __iter__(self):
        self._refresh()
        return iter(self._tree)

    def __len__(self):
        self._refresh()
        return len(self._tree)


class LocalRepo(Repo):
    """A repo on the local filesystem."""
    def __init__(self, path):
        super().__init__()
        self.base_path = path

    def _refresh(self):
        self._tree = {}
        packages = os.listdir(self.base_path)
        for p in packages:
            self._tree[p] = {}
            for artifact in os.listdir(os.path.join(self.base_path, p)):
                self._tree[p][artifact] = LocalPackage(os.path.join(
                    self.base_path, p, artifact
                ))


class LocalPackage:
    def __init__(self, path):
        self.path = path

    def download(self):
        return functools.partial(open, self.path, "rb")


class S3Repo(Repo):
    """A repo hosted on a S3 bucket.

    The repo should have folder-like keys, with the first element
    representing the package name, and the second element containing
    the artifact name.
    """
    def __init__(self, bucket):
        super().__init__()
        self.bucket = boto3.resource('s3').Bucket(bucket)

    def _refresh(self):
        self._tree = {}
        for obj in self.bucket.objects.all():
            key = obj.key
            pkg_name, artifact_name = key.split("/", 1)
            pkg_dict = self._tree.setdefault(pkg_name, {})
            pkg_dict[artifact_name] = S3Package(self.bucket.name, obj.key)


class S3Package:
    def __init__(self, bucket, key):
        self.bucket = bucket
        self.key = key

    def download(self):
        # Generate URL for download
        client = boto3.client("s3")
        url = client.generate_presigned_url(
            "get_object",
            {"Bucket": self.bucket, "Key": self.key},
            ExpiresIn=180, HttpMethod="GET"
        )

        # Return a custom reader factory that uses aiohttp for the download
        return functools.partial(AiohttpReader, url)


class AiohttpReader:
    """Wraps a 'get' from aiohttp into a context manager that exposes a
    reader interface.
    """
    def __init__(self, url):
        self.url = url

    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        self._cm = self.session.get(self.url)
        resp = await self._cm.__aenter__()
        return resp.content

    async def __aexit__(self, *args, **kwargs):
        await self._cm.__aexit__(*args, **kwargs)
        await self.session.close()


def normalize(name):
    """Normalize a package name according to PEP 503."""
    return re.sub(r"[-_.]+", "-", name).lower()
